// PerNeuron Plug-in
// Initial code generated by Softimage SDK Wizard
// Executed Sat Jul 2 18:20:16 UTC+0300 2016 by Pavel
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_customoperator.h>
#include <xsi_factory.h>
#include <xsi_ppglayout.h>
#include <xsi_model.h>
#include <xsi_kinematicstate.h>
#include <xsi_kinematics.h>
#include <xsi_operatorcontext.h>
#include <xsi_project.h>
#include <xsi_ppgeventcontext.h>
#include <xsi_selection.h>
#include <xsi_null.h>
#include "DeviceInfo.h"
//#include "MyMath.h"

static _DeviceInfo g_pDeviceinfo;

using namespace XSI; 
SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Pavel");
	in_reg.PutName(L"PerNeuron Plug-in");
	in_reg.PutVersion(1,0);
// 	in_reg.RegisterEvent(L"KeyDown",siOnKeyDown);
// 	in_reg.RegisterEvent(L"KeyUp",siOnKeyUp);
	in_reg.RegisterEvent(L"StartAnimation",siOnStartAnimation);
	in_reg.RegisterEvent(L"StopAnimation",siOnStopAnimation);
	in_reg.RegisterEvent(L"TimeChange",siOnTimeChange);
	in_reg.RegisterTimerEvent(L"Timerpn",33,1000);

	in_reg.RegisterOperator(L"PN_Cpp");
	in_reg.RegisterCommand(L"PerceptionNeuron");
	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSI::X3DObject GetObjectByID( int i, XSI::X3DObject null_guide, XSI::X3DObject &root )
{
	if(i == SPINE)
		null_guide = root.FindChild(L"Spine",L"",XSI::CStringArray());
	if(i == SPINE_1)
		null_guide = root.FindChild(L"Spine1",L"",XSI::CStringArray());
	if(i == SPINE_2)
		null_guide = root.FindChild(L"Spine2",L"",XSI::CStringArray());
	if(i == SPINE_3)
		null_guide = root.FindChild(L"Spine3",L"",XSI::CStringArray());
	if(i == NECK)
		null_guide = root.FindChild(L"Neck",L"",XSI::CStringArray());
	if(i == HEAD)
		null_guide = root.FindChild(L"Head",L"",XSI::CStringArray());



	if(i == RIGHT_SHOULDER)
		null_guide = root.FindChild(L"RightShoulder",L"",XSI::CStringArray());
	if(i == RIGHT_ARM)
		null_guide = root.FindChild(L"RightArm",L"",XSI::CStringArray());
	if(i == RIGHT_FORE_ARM)
		null_guide = root.FindChild(L"RightForeArm",L"",XSI::CStringArray());
	if(i == RIGHT_HAND)
		null_guide = root.FindChild(L"RightHand",L"",XSI::CStringArray());


	if(i == LEFT_SHOULDER)
		null_guide = root.FindChild(L"LeftShoulder",L"",XSI::CStringArray());
	if(i == LEFT_ARM)
		null_guide = root.FindChild(L"LeftArm",L"",XSI::CStringArray());
	if(i == LEFT_FORE_ARM)
		null_guide = root.FindChild(L"LeftForeArm",L"",XSI::CStringArray());
	if(i == LEFT_HAND)
		null_guide = root.FindChild(L"LeftHand",L"",XSI::CStringArray());



	if(i == RIGHT_UP_LEG)
		null_guide = root.FindChild(L"RightUpLeg",L"",XSI::CStringArray());
	if(i == RIGHT_LEG)
		null_guide = root.FindChild(L"RightLeg",L"",XSI::CStringArray());
	if(i == RIGHT_FOOT)
		null_guide = root.FindChild(L"RightFoot",L"",XSI::CStringArray());

	if(i == LEFT_UP_LEG)
		null_guide = root.FindChild(L"LeftUpLeg",L"",XSI::CStringArray());
	if(i == LEFT_LEG)
		null_guide = root.FindChild(L"LeftLeg",L"",XSI::CStringArray());
	if(i == LEFT_FOOT)
		null_guide = root.FindChild(L"LeftFoot",L"",XSI::CStringArray());





	//FINGERS RIGHT
	if(i == RIGHT_HAND_THUMB_1)
		null_guide = root.FindChild(L"RightHandThumb1",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_THUMB_2)
		null_guide = root.FindChild(L"RightHandThumb2",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_THUMB_3)
		null_guide = root.FindChild(L"RightHandThumb3",L"",XSI::CStringArray());



	if(i == RIGHT_HAND_INDEX_1)
		null_guide = root.FindChild(L"RightHandIndex1",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_INDEX_2)
		null_guide = root.FindChild(L"RightHandIndex2",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_INDEX_3)
		null_guide = root.FindChild(L"RightHandIndex3",L"",XSI::CStringArray());



	if(i == RIGHT_HAND_MIDDLE_1)
		null_guide = root.FindChild(L"RightHandMiddle1",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_MIDDLE_2)
		null_guide = root.FindChild(L"RightHandMiddle2",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_MIDDLE_3)
		null_guide = root.FindChild(L"RightHandMiddle3",L"",XSI::CStringArray());


	if(i == RIGHT_HAND_RING_1)
		null_guide = root.FindChild(L"RightHandRing1",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_RING_2)
		null_guide = root.FindChild(L"RightHandRing2",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_RING_3)
		null_guide = root.FindChild(L"RightHandRing3",L"",XSI::CStringArray());



	if(i == RIGHT_HAND_PINKY_1)
		null_guide = root.FindChild(L"RightHandPinky1",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_PINKY_2)
		null_guide = root.FindChild(L"RightHandPinky2",L"",XSI::CStringArray());

	if(i == RIGHT_HAND_PINKY_3)
		null_guide = root.FindChild(L"RightHandPinky3",L"",XSI::CStringArray());


	//FINGERS LEFT
	if(i == LEFT_HAND_THUMB_1)
		null_guide = root.FindChild(L"LeftHandThumb1",L"",XSI::CStringArray());

	if(i == LEFT_HAND_THUMB_2)
		null_guide = root.FindChild(L"LeftHandThumb2",L"",XSI::CStringArray());

	if(i == LEFT_HAND_THUMB_3)
		null_guide = root.FindChild(L"LeftHandThumb3",L"",XSI::CStringArray());



	if(i == LEFT_HAND_INDEX_1)
		null_guide = root.FindChild(L"LeftHandIndex1",L"",XSI::CStringArray());

	if(i == LEFT_HAND_INDEX_2)
		null_guide = root.FindChild(L"LeftHandIndex2",L"",XSI::CStringArray());

	if(i == LEFT_HAND_INDEX_3)
		null_guide = root.FindChild(L"LeftHandIndex3",L"",XSI::CStringArray());



	if(i == LEFT_HAND_MIDDLE_1)
		null_guide = root.FindChild(L"LeftHandMiddle1",L"",XSI::CStringArray());

	if(i == LEFT_HAND_MIDDLE_2)
		null_guide = root.FindChild(L"LeftHandMiddle2",L"",XSI::CStringArray());

	if(i == LEFT_HAND_MIDDLE_3)
		null_guide = root.FindChild(L"LeftHandMiddle3",L"",XSI::CStringArray());


	if(i == LEFT_HAND_RING_1)
		null_guide = root.FindChild(L"LeftHandRing1",L"",XSI::CStringArray());

	if(i == LEFT_HAND_RING_2)
		null_guide = root.FindChild(L"LeftHandRing2",L"",XSI::CStringArray());

	if(i == LEFT_HAND_RING_3)
		null_guide = root.FindChild(L"LeftHandRing3",L"",XSI::CStringArray());



	if(i == LEFT_HAND_PINKY_1)
		null_guide = root.FindChild(L"LeftHandPinky1",L"",XSI::CStringArray());

	if(i == LEFT_HAND_PINKY_2)
		null_guide = root.FindChild(L"LeftHandPinky2",L"",XSI::CStringArray());

	if(i == LEFT_HAND_PINKY_3)
		null_guide = root.FindChild(L"LeftHandPinky3",L"",XSI::CStringArray());


	if(i == HIPS)
		null_guide = root.FindChild(L"Hips",L"",XSI::CStringArray());		
	
	return null_guide;
}

void AddFcurves(bool isDisconnect = false)
{
	XSI::Application app;
	//XSI::Model hips = app.GetActiveSceneRoot();
	XSI::X3DObject hips = g_pDeviceinfo.Hips;
	for (int i = 0; i < NUMBONES; i++)
	{

		XSI::X3DObject null_guide;
		null_guide = GetObjectByID(i, null_guide, hips);


		if(!isDisconnect)
		{
			XSI::Parameter rotx( null_guide.GetParameter(L"rotx") );
			rotx.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_RX);
			XSI::Parameter roty( null_guide.GetParameter(L"roty") );
			roty.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_RY);
			XSI::Parameter rotz( null_guide.GetParameter(L"rotz") );
			rotz.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_RZ);
			if(i == HIPS)
			{
				XSI::Parameter posx( null_guide.GetParameter(L"posx") );
				posx.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_TX);
				XSI::Parameter posy( null_guide.GetParameter(L"posy") );
				posy.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_TY);
				XSI::Parameter posz( null_guide.GetParameter(L"posz") );
				posz.AddFCurve( XSI::siUnknownFCurve,g_pDeviceinfo._sensors[i].fc_TZ);
			}
		}else{
			null_guide.GetParameter(L"rotx").Disconnect() ;
			null_guide.GetParameter(L"roty").Disconnect() ;
			null_guide.GetParameter(L"rotz").Disconnect() ;
// 
// 			if(i == HIPS)
// 			{
				null_guide.GetParameter(L"posx").Disconnect() ;
				null_guide.GetParameter(L"posy").Disconnect() ;
				null_guide.GetParameter(L"posz").Disconnect() ;
				
//			}
		}
	

		//g_pDeviceinfo._sensors[i].fc_RX = XSI::FCurve();
		//g_pDeviceinfo._sensors[i].fc_RY = XSI::FCurve();
		//g_pDeviceinfo._sensors[i].fc_RZ = XSI::FCurve();

	}
}
XSIPLUGINCALLBACK CStatus PerceptionNeuron_Execute()
{
// 	XSI::Context ctxt( in_ctxt );
// 	XSI::CValueArray args = ctxt.GetAttribute(L"Arguments");

	// A 3d object with a mesh geometry must be selected

	XSI::X3DObject arg_0(Application().GetSelection()[0]);
	if (!arg_0.IsValid()) 
		return XSI::CStatus::False;
	g_pDeviceinfo.Hips = arg_0;
	g_pDeviceinfo.RootNodePN = arg_0;
	// Create scene elements
	Model root = Application().GetActiveSceneRoot() ;
// 
 	XSI::Null sphereOut;
 	g_pDeviceinfo.RootNodePN.AddNull(L"Perception", sphereOut);

	X3DObject null_guide = g_pDeviceinfo.RootNodePN.FindChild(L"Spine",L"",XSI::CStringArray());
	Application().LogMessage( L"FindChild : " + null_guide.GetName() );
		
// 
//  	X3DObject cubeIn;
//  	root.AddGeometry(L"Cube",L"MeshSurface", L"Driver", cubeIn);

	null_guide = g_pDeviceinfo.RootNodePN.FindChild(L"Hips",L"",XSI::CStringArray());

//	KinematicState basePos = cubeIn.GetKinematics().GetGlobal() ;

// 	CRefArray inputs(1) ;
// 	inputs[0] = basePos.GetRef() ;

	
	KinematicState endPos = sphereOut.GetKinematics().GetGlobal() ;
	//
	// Pull the operator
	// 
	CustomOperator op = endPos.AddCustomOp( L"PN_Cpp" ) ;
	//op.PutMute(true);
	// Tip: To demonstrate more visually, move the cube and watch the sphere bounce around
	// under it
	//AddFcurves();
	g_pDeviceinfo.connect();


	return CStatus::OK ;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	g_pDeviceinfo.disconnect();
	XSI::CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}






// Callback for the StartAnimation event.
SICALLBACK StartAnimation_OnEvent( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Application().LogMessage(L"StartAnimation_OnEvent called",siVerboseMsg);
	g_pDeviceinfo.isRecord = true;
//	g_pDeviceinfo.isWrited = false;
// 	TODO: Put your code here.8
	//XSI::Application app;
	//XSI::Model root = app.GetActiveSceneRoot();
	if(g_pDeviceinfo.isWrited)
		AddFcurves(true);
 	for (int i = 0; i < NUMBONES; i++)
 	{
 
 		g_pDeviceinfo._sensors[i].fc_tmp_RX.clear();
 		g_pDeviceinfo._sensors[i].fc_tmp_RX.resize(0);
 		
 		g_pDeviceinfo._sensors[i].fc_tmp_RY.clear();
 		g_pDeviceinfo._sensors[i].fc_tmp_RY.resize(0);
 
 		g_pDeviceinfo._sensors[i].fc_tmp_RZ.clear();
 		g_pDeviceinfo._sensors[i].fc_tmp_RZ.resize(0);


		g_pDeviceinfo._sensors[i].fc_tmp_TX.clear();
		g_pDeviceinfo._sensors[i].fc_tmp_TX.resize(0);

		g_pDeviceinfo._sensors[i].fc_tmp_TY.clear();
		g_pDeviceinfo._sensors[i].fc_tmp_TY.resize(0);

		g_pDeviceinfo._sensors[i].fc_tmp_TZ.clear();
		g_pDeviceinfo._sensors[i].fc_tmp_TZ.resize(0);
 	}
	
// 	Return value is ignored as this event can not be aborted.
	return CStatus::OK;
}




// Callback for the StopAnimation event.
SICALLBACK StopAnimation_OnEvent( CRef& in_ctxt )
{
	

	Context ctxt( in_ctxt );
	Application().LogMessage(L"StopAnimation_OnEvent called",siVerboseMsg);
	g_pDeviceinfo.isRecord = false;
//	g_pDeviceinfo.isWrited = false;
	if(g_pDeviceinfo.isWrited)
	{
		AddFcurves();

 		for (int i = 0; i < NUMBONES; i++)
 		{
 			for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_RX.size(); t++)
 			{
 				key fck_x = g_pDeviceinfo._sensors[i].fc_tmp_RX[t];
 				g_pDeviceinfo._sensors[i].fc_RX.AddKey(fck_x.frame,fck_x.value);
 			}

			for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_RY.size(); t++)
			{
				key fck_y = g_pDeviceinfo._sensors[i].fc_tmp_RY[t];
				g_pDeviceinfo._sensors[i].fc_RY.AddKey(fck_y.frame,fck_y.value);
			}
			for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_RZ.size(); t++)
			{
				key fck_z = g_pDeviceinfo._sensors[i].fc_tmp_RZ[t];
				g_pDeviceinfo._sensors[i].fc_RZ.AddKey(fck_z.frame,fck_z.value);
			}

			if ( i == HIPS)
			{
				for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_TX.size(); t++)
				{
					key fck_x = g_pDeviceinfo._sensors[i].fc_tmp_TX[t];
					g_pDeviceinfo._sensors[i].fc_TX.AddKey(fck_x.frame,fck_x.value);
				}

				for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_TY.size(); t++)
				{
					key fck_y = g_pDeviceinfo._sensors[i].fc_tmp_TY[t];
					g_pDeviceinfo._sensors[i].fc_TY.AddKey(fck_y.frame,fck_y.value);
				}
				for (int t = 0; t < g_pDeviceinfo._sensors[i].fc_tmp_TZ.size(); t++)
				{
					key fck_z = g_pDeviceinfo._sensors[i].fc_tmp_TZ[t];
					g_pDeviceinfo._sensors[i].fc_TZ.AddKey(fck_z.frame,fck_z.value);
				}
			}
		}
	}
// 	TODO: Put your code here.

// 	Return value is ignored as this event can not be aborted.
	return CStatus::OK;
}

void UpdateModel()
{
	XSI::Application app;
	XSI::X3DObject hips = g_pDeviceinfo.Hips;
	XSI::Project prj = app.GetActiveProject();
	XSI::CRefArray proplist = prj.GetProperties();
	XSI::Property playctrl( proplist.GetItem(L"Play Control") );
	float cur_frame = playctrl.GetParameterValue(L"Current");

	if(g_pDeviceinfo._last_frame != cur_frame)
	{
		g_pDeviceinfo._last_frame = cur_frame;
		//app.LogMessage(playctrl.GetParameterValue(L"Current"));
	}

	for (int i = 0; i < NUMBONES; i++)
	{
		MATH::CRotation rot_hips;
		if( i == HIPS||
			i == RIGHT_UP_LEG ||
			i == RIGHT_LEG ||
			i == RIGHT_FOOT ||
			i == LEFT_UP_LEG ||
			i == LEFT_LEG ||
			i == LEFT_FOOT ||
			
			i == RIGHT_SHOULDER ||
			i == RIGHT_ARM ||
			i == RIGHT_FORE_ARM ||
			i == RIGHT_HAND ||

			i == LEFT_SHOULDER ||
			i == LEFT_ARM ||
			i == LEFT_FORE_ARM ||
			i == LEFT_HAND ||

			i == HEAD ||
			i == NECK ||
			i == SPINE_3||
			i == SPINE_2 ||
			i == SPINE_1 ||
			i == SPINE )
		{
			rot_hips = MATH::CRotation(MATH::CQuaternion(g_pDeviceinfo._sensorsCal[i].m_calcQs, g_pDeviceinfo._sensorsCal[i].m_calcQx, g_pDeviceinfo._sensorsCal[i].m_calcQy, g_pDeviceinfo._sensorsCal[i].m_calcQz ));
		}else
		{
			rot_hips = MATH::CRotation(XSI::MATH::DegreesToRadians(g_pDeviceinfo._sensors[i].angX),XSI::MATH::DegreesToRadians(g_pDeviceinfo._sensors[i].angY),XSI::MATH::DegreesToRadians(g_pDeviceinfo._sensors[i].angZ));
		}



		XSI::X3DObject null_guide;

		null_guide = GetObjectByID(i, null_guide, hips);

		if(i == HIPS)
		{
			MATH::CVector3 tran_hips(g_pDeviceinfo._sensors[i].dispX - g_pDeviceinfo._sensorsCal[i].m_calcPx,
				g_pDeviceinfo._sensors[i].dispY- g_pDeviceinfo._sensorsCal[i].m_calcPy,
				g_pDeviceinfo._sensors[i].dispZ- g_pDeviceinfo._sensorsCal[i].m_calcPz);
			//tran_hips += MATH::CVector3(g_pDeviceinfo._sensorsCal[HIPS].m_calcPx, g_pDeviceinfo._sensorsCal[HIPS].m_calcPy, g_pDeviceinfo._sensorsCal[HIPS].m_calcPz);
			null_guide = g_pDeviceinfo.Hips;
			if(null_guide.IsValid())
			{
				null_guide.PutLocalTranslation(tran_hips);
				null_guide.PutLocalRotation(rot_hips);
			}
		}else if(null_guide.IsValid() )
		{
			null_guide.PutLocalRotation(rot_hips);
		}
		if (g_pDeviceinfo.isRecord && g_pDeviceinfo.isWrited)
		{
			XSI::MATH::CRotation rot = null_guide.GetLocalRotation();
			XSI::MATH::CVector3 rot_xyz =  rot.GetXYZAngles();
			// 
			// 			g_pDeviceinfo._sensors[i].fc_RX.AddKey(cur_frame, radToDeg(rot_xyz.GetX()));
			// 			g_pDeviceinfo._sensors[i].fc_RY.AddKey(cur_frame, radToDeg(rot_xyz.GetY()));
			// 			g_pDeviceinfo._sensors[i].fc_RZ.AddKey(cur_frame, radToDeg(rot_xyz.GetZ());
			key tmp_rx, tmp_ry, tmp_rz, tmp_tx, tmp_ty, tmp_tz ;
			tmp_rx.frame = cur_frame;
			tmp_rx.value =  XSI::MATH::RadiansToDegrees(rot_xyz.GetX());
			g_pDeviceinfo._sensors[i].fc_tmp_RX.push_back(tmp_rx);

			tmp_ry.frame = cur_frame;
			tmp_ry.value = XSI::MATH::RadiansToDegrees(rot_xyz.GetY());
			g_pDeviceinfo._sensors[i].fc_tmp_RY.push_back(tmp_ry);

			tmp_rz.frame = cur_frame;
			tmp_rz.value =  XSI::MATH::RadiansToDegrees(rot_xyz.GetZ());
			g_pDeviceinfo._sensors[i].fc_tmp_RZ.push_back(tmp_rz);

			if(i == HIPS)
			{
				tmp_tx.frame = cur_frame;
				tmp_tx.value = null_guide.GetLocalTranslation().GetX();
				g_pDeviceinfo._sensors[i].fc_tmp_TX.push_back(tmp_tx);
				tmp_ty.frame = cur_frame;
				tmp_ty.value = null_guide.GetLocalTranslation().GetY();
				g_pDeviceinfo._sensors[i].fc_tmp_TY.push_back(tmp_ty);
				tmp_tz.frame = cur_frame;
				tmp_tz.value = null_guide.GetLocalTranslation().GetZ();
				g_pDeviceinfo._sensors[i].fc_tmp_TZ.push_back(tmp_tz);
			}

		}

	}
}
// Callback for the TimeChange event.
SICALLBACK TimeChange_OnEvent( CRef& in_ctxt )
{
// 	Context ctxt( in_ctxt );
// 	Application().LogMessage(L"TimeChange_OnEvent called",siVerboseMsg);
// 
// 	Application().LogMessage(L"Frame: " + XSI::CString(ctxt.GetAttribute(L"Frame")),siVerboseMsg);

// 	TODO: Put your code here.
	if (g_pDeviceinfo.isRecord && g_pDeviceinfo.isWrited)
		UpdateModel();
// 	Return value is ignored as this event can not be aborted.
	return CStatus::OK;
}




// Callback for the Timer event.
SICALLBACK Timerpn_OnEvent( CRef& in_ctxt )
{
	if(!g_pDeviceinfo.isActivated)
		return CStatus::False;
	//Context ctxt( in_ctxt );
//	Application().LogMessage(L"Timer_OnEvent called",siVerboseMsg);

//	OperatorContext ctxt( in_ctxt ) ;

	//KinematicState out = ctxt.GetOutputTarget() ;

	//KinematicState in( ctxt.GetInputValue( 0 ) ); // Read the input

	//double SpringScale = ctxt.GetParameterValue( L"SpringScale" ) ;
	//double Length = ctxt.GetParameterValue( L"Length" ) ;
	//double SpringK = ctxt.GetParameterValue( L"SpringK" ) ;
	//double mass = ctxt.GetParameterValue( L"Mass" ) ;
	//double gravity = ctxt.GetParameterValue( L"Gravity" ) ;
	//double resistance = ctxt.GetParameterValue( L"Resistance" ) ;
	//double bounce = ctxt.GetParameterValue( L"bounce" ) ;
	//bool isWrite = ctxt.GetParameterValue( L"write" ) ;
	if (!g_pDeviceinfo.isRecord ||  !g_pDeviceinfo.isWrited)
		UpdateModel();

	
// 	This event can be aborted by returning CStatus::OK or CStatus::False if you don't want to abort.
	return CStatus::False;
}

XSIPLUGINCALLBACK CStatus PN_Cpp_Define( CRef& in_ctxt )
{
	Context ctxt( in_ctxt ) ;
	CustomOperator op = ctxt.GetSource() ;

	//
	// Build parameters
	//

	Parameter newParam ;

	CRef pdef = Application().GetFactory().CreateParamDef( L"SpringScale", CValue::siDouble, 0.05, 0.0, 1.0 );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"Length", CValue::siDouble, 3.0, 0.0, 100.0 );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"SpringK", CValue::siDouble, 40.0, 0.0, 100.0 );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"Mass", CValue::siDouble, 30.0, 0.0, 100.0 );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"Tcp", CValue::siString, L"192.168.1.124" );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"Port_BHV", CValue::siString, L"7001" );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"Port_CALC", CValue::siString, L"7009" );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"write", CValue::siBool, true );
	op.AddParameter( pdef, newParam ) ;

	pdef = Application().GetFactory().CreateParamDef( L"active", CValue::siBool, true );
	op.AddParameter( pdef, newParam ) ;

	// This is important so that the spring continues to act during playback
	op.PutAlwaysEvaluate(true) ; 

	// This enables debugging output but will slow down the operator
#ifndef NDEBUG
	op.PutDebug( 1 ) ;
#endif
	return CStatus::OK ;
}


XSIPLUGINCALLBACK CStatus PN_Cpp_DefineLayout( CRef& in_ctxt )
{
	PPGLayout layout = Context(in_ctxt).GetSource() ;
	layout.Clear() ;

	layout.AddItem( L"SpringScale" ) ;
	layout.AddItem( L"Length" ) ;
	layout.AddItem( L"SpringK" ) ;
	layout.AddItem( L"Mass" ) ;
	layout.AddItem( L"Tcp" ) ;
	layout.AddItem( L"Port_BHV" ) ;
	layout.AddItem( L"Port_CALC" ) ;
	layout.AddButton(L"Connect","Connect...");
	layout.AddButton(L"Disconnect","Disconnect...");
	layout.AddButton(L"Plot","Plot animation...");
	layout.AddItem( L"write" ) ;
	layout.AddItem( L"active" ) ;
	
	return CStatus::OK ;
}
SICALLBACK PN_Cpp_PPGEvent( const CRef& in_ref )
{
	PPGEventContext in_ctxt( in_ref );
	switch ( in_ctxt.GetEventID() )
	{
		case siButtonClicked:
			Application().LogMessage(XSI::CString("Box_PPGEvent: siButtonClicked"));
			CValue buttonPressed = in_ctxt.GetAttribute( L"Button" ) ;
			if ( buttonPressed.GetAsText() == "Connect" )
			{
				//Application().LogMessage(XSI::CString("Clicked"));
				g_pDeviceinfo.connect();
			}
			if ( buttonPressed.GetAsText() == "Disconnect" )
			{
				//Application().LogMessage(XSI::CString("Clicked"));
				g_pDeviceinfo.disconnect();
			}
			if ( buttonPressed.GetAsText() == "Plot" )
			{
				//Application().LogMessage(XSI::CString("Clicked"));
				CValueArray args(0);CValue retVal;
				Application().ExecuteCommand(L"PlayRealTime",args,retVal);
			}
			
	}
	return CStatus::OK;

}

XSIPLUGINCALLBACK CStatus PN_Cpp_Update( CRef& in_ctxt )
{
	OperatorContext ctxt( in_ctxt ) ;
	
	g_pDeviceinfo.isWrited = ctxt.GetParameterValue( L"write" ) ;
	g_pDeviceinfo.isActivated =  ctxt.GetParameterValue( L"active" ) ;
	
	g_pDeviceinfo.m_strIPAddress = ctxt.GetParameterValue( L"Tcp" ).GetAsText().GetWideString() ;
	g_pDeviceinfo.m_strTCP_BHVPort = ctxt.GetParameterValue( L"Port_BHV" ).GetAsText().GetWideString() ;
	g_pDeviceinfo.m_strTCP_CALCPort = ctxt.GetParameterValue( L"Port_CALC" ).GetAsText().GetWideString() ;
// 	if(g_pDeviceinfo._last_frame != cur_frame)
// 	{
// 		g_pDeviceinfo._last_frame = cur_frame;
// 		app.LogMessage(playctrl.GetParameterValue(L"Current"));
// 	}
// 	


	return CStatus::OK ;
}